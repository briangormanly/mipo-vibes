{"ast":null,"code":"import * as i0 from \"@angular/core\";\nexport let WeightingService = /*#__PURE__*/(() => {\n  class WeightingService {\n    compute(input) {\n      const adjustedVariables = this.applyRefusalAdjustments(input.targetSet.variables, input.refusals).filter(variable => input.variables.includes(variable.key));\n      const sampleShares = this.buildSampleShareMap(input.counts);\n      const states = {};\n      for (const variable of adjustedVariables) {\n        states[variable.key] = this.computeVariableWeights(variable, sampleShares[variable.key] ?? {}, input.caps);\n      }\n      const partyVariable = input.targetSet.variables.find(variable => variable.key === input.partyVariable);\n      if (partyVariable) {\n        states[partyVariable.key] = this.computeVariableWeights(partyVariable, sampleShares[partyVariable.key] ?? {}, input.caps);\n        this.applyPartyPostStratification(states, input.partyTargets, input.caps);\n      }\n      return {\n        categoryTable: this.flattenCategoryResults(states),\n        diagnostics: this.summarizeDiagnostics(states)\n      };\n    }\n    applyRefusalAdjustments(variables, refusals) {\n      return variables.map(variable => {\n        const refusalRate = refusals[variable.key] ?? 0;\n        if (refusalRate <= 0) {\n          return variable;\n        }\n        const adjustedTotal = variable.categories.reduce((sum, category) => sum + category.share * (1 - refusalRate), 0);\n        return {\n          ...variable,\n          categories: variable.categories.map(category => ({\n            ...category,\n            share: category.share * (1 - refusalRate) / adjustedTotal || 0\n          }))\n        };\n      });\n    }\n    buildSampleShareMap(counts) {\n      const result = {};\n      const totals = {};\n      for (const count of counts) {\n        result[count.variable] = result[count.variable] ?? {};\n        result[count.variable][count.category] = (result[count.variable][count.category] ?? 0) + count.n;\n        totals[count.variable] = (totals[count.variable] ?? 0) + count.n;\n      }\n      for (const [variable, categories] of Object.entries(result)) {\n        const total = totals[variable] ?? 0;\n        if (total === 0) {\n          continue;\n        }\n        for (const [category, value] of Object.entries(categories)) {\n          categories[category] = value / total;\n        }\n      }\n      return result;\n    }\n    clip(value, caps) {\n      if (value < caps.min) {\n        return {\n          weight: caps.min,\n          capped: true\n        };\n      }\n      if (value > caps.max) {\n        return {\n          weight: caps.max,\n          capped: true\n        };\n      }\n      return {\n        weight: value,\n        capped: false\n      };\n    }\n    computeVariableWeights(variable, sampleShares, caps) {\n      const state = {};\n      for (const category of variable.categories) {\n        const observed = sampleShares[category.key] ?? 0;\n        const rawWeight = observed === 0 ? caps.max : category.share / observed;\n        const {\n          weight,\n          capped\n        } = this.clip(rawWeight, caps);\n        state[category.key] = {\n          target: category.share,\n          sampleShare: observed,\n          weight,\n          capped\n        };\n      }\n      return state;\n    }\n    applyPartyPostStratification(states, partyTargets, caps) {\n      const partyState = states.PARTY;\n      if (!partyState) {\n        return;\n      }\n      for (const [categoryKey, state] of Object.entries(partyState)) {\n        const desiredShare = partyTargets[categoryKey] ?? state.target;\n        const observed = state.sampleShare;\n        const rawWeight = observed === 0 ? caps.max : desiredShare / observed;\n        const {\n          weight,\n          capped\n        } = this.clip(rawWeight, caps);\n        state.weight = weight;\n        state.capped = capped;\n        state.target = desiredShare;\n      }\n    }\n    summarizeDiagnostics(states) {\n      const capHits = [];\n      for (const [variable, categories] of Object.entries(states)) {\n        for (const [category, state] of Object.entries(categories)) {\n          if (state.capped) {\n            capHits.push({\n              variable,\n              category,\n              suggestedWeight: state.target / Math.max(state.sampleShare, 1e-6),\n              cappedTo: state.weight\n            });\n          }\n        }\n      }\n      return {\n        iterations: 1,\n        converged: true,\n        capHits\n      };\n    }\n    flattenCategoryResults(states) {\n      const rows = [];\n      for (const [variable, categories] of Object.entries(states)) {\n        for (const [category, state] of Object.entries(categories)) {\n          rows.push({\n            variable,\n            category,\n            target: state.target,\n            sampleShare: state.sampleShare,\n            weight: state.weight,\n            capped: state.capped\n          });\n        }\n      }\n      return rows;\n    }\n    static {\n      this.ɵfac = function WeightingService_Factory(t) {\n        return new (t || WeightingService)();\n      };\n    }\n    static {\n      this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n        token: WeightingService,\n        factory: WeightingService.ɵfac,\n        providedIn: 'root'\n      });\n    }\n  }\n  return WeightingService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}
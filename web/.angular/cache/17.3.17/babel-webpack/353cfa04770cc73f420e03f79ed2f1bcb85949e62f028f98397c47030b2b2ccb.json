{"ast":null,"code":"import _asyncToGenerator from \"/Users/briangormanly/projects/mipo/mipo-vibes/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { DecimalPipe, NgClass, NgFor, NgIf } from '@angular/common';\nimport { Component, computed, inject, signal } from '@angular/core';\nimport { FormsModule } from '@angular/forms';\nimport { HttpClient } from '@angular/common/http';\nimport { WeightingService } from './services/weighting.service';\nlet AppComponent = class AppComponent {\n  constructor() {\n    this.http = inject(HttpClient);\n    this.weightingService = inject(WeightingService);\n    this.title = 'MIPO Weighting Calculator';\n    this.targetSet = signal(null);\n    this.selectedVariables = signal(new Set(['RACE', 'GENDER', 'AGE', 'INCOME', 'REGION']));\n    this.refusalRates = signal({\n      INCOME: 0.13\n    });\n    this.partyTargets = signal({\n      DEM: 0.33,\n      REP: 0.3,\n      IND_OTHER: 0.37\n    });\n    this.caps = signal({\n      min: 0.5,\n      max: 2.0\n    });\n    this.counts = signal({});\n    this.computeResult = signal(null);\n    this.isComputing = signal(false);\n    this.errorMessage = signal(null);\n    this.categoriesTable = computed(() => this.computeResult()?.categoryTable ?? []);\n    this.partyCategories = computed(() => {\n      const target = this.targetSet();\n      if (!target) {\n        return [];\n      }\n      const partyVariable = target.variables.find(variable => variable.key === 'PARTY');\n      return partyVariable?.categories ?? [];\n    });\n  }\n  ngOnInit() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const target = yield _this.http.get('assets/targets/acs_all_adults_national.json').toPromise();\n      if (target) {\n        _this.targetSet.set(target);\n        _this.initializeCounts(target.variables);\n        const partyVariable = target.variables.find(variable => variable.key === 'PARTY');\n        if (partyVariable) {\n          const defaultPartyTargets = {};\n          for (const category of partyVariable.categories) {\n            defaultPartyTargets[category.key] = category.share;\n          }\n          _this.partyTargets.set(defaultPartyTargets);\n        }\n      }\n    })();\n  }\n  toggleVariable(variableKey, checked) {\n    const next = new Set(this.selectedVariables().values());\n    if (checked) {\n      next.add(variableKey);\n    } else {\n      next.delete(variableKey);\n    }\n    this.selectedVariables.set(next);\n  }\n  updateRefusal(variableKey, event) {\n    const value = Number(event.target.value);\n    const next = {\n      ...this.refusalRates()\n    };\n    if (Number.isNaN(value)) {\n      delete next[variableKey];\n    } else {\n      next[variableKey] = Math.min(Math.max(value, 0), 0.9);\n    }\n    this.refusalRates.set(next);\n  }\n  updatePartyTarget(categoryKey, event) {\n    const value = Number(event.target.value);\n    const next = {\n      ...this.partyTargets()\n    };\n    if (!Number.isNaN(value)) {\n      next[categoryKey] = value;\n    }\n    this.partyTargets.set(next);\n  }\n  updateCaps(key, event) {\n    const value = Number(event.target.value);\n    const next = {\n      ...this.caps()\n    };\n    if (!Number.isNaN(value)) {\n      next[key] = value;\n    }\n    this.caps.set(next);\n  }\n  updateCount(variableKey, categoryKey, event) {\n    const rawValue = event.target.value;\n    const value = Number(rawValue);\n    const next = this.cloneCounts();\n    if (!next[variableKey]) {\n      next[variableKey] = {};\n    }\n    next[variableKey][categoryKey] = Number.isNaN(value) ? 0 : Math.max(value, 0);\n    this.counts.set(next);\n  }\n  resetCounts() {\n    const target = this.targetSet();\n    if (!target) {\n      return;\n    }\n    this.initializeCounts(target.variables);\n    this.computeResult.set(null);\n  }\n  compute() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const target = _this2.targetSet();\n      if (!target) {\n        return;\n      }\n      _this2.isComputing.set(true);\n      _this2.errorMessage.set(null);\n      try {\n        const counts = _this2.extractCounts();\n        const result = _this2.weightingService.compute({\n          targetSet: target,\n          variables: Array.from(_this2.selectedVariables()),\n          partyVariable: 'PARTY',\n          partyTargets: _this2.partyTargets(),\n          refusals: _this2.refusalRates(),\n          caps: _this2.caps(),\n          counts\n        });\n        _this2.computeResult.set(result);\n      } catch (error) {\n        console.error(error);\n        _this2.errorMessage.set(error.message ?? 'Unable to compute weights');\n      } finally {\n        _this2.isComputing.set(false);\n      }\n    })();\n  }\n  exportCategoryCsv() {\n    const result = this.computeResult();\n    if (!result) {\n      return;\n    }\n    const header = 'Variable,Category,Target,Sample Share,Weight,Capped\\n';\n    const rows = result.categoryTable.map(row => `${row.variable},${row.category},${row.target.toFixed(4)},${row.sampleShare.toFixed(4)},${row.weight.toFixed(4)},${row.capped}`).join('\\n');\n    const csv = `${header}${rows}`;\n    const blob = new Blob([csv], {\n      type: 'text/csv'\n    });\n    const url = URL.createObjectURL(blob);\n    const link = document.createElement('a');\n    link.href = url;\n    link.download = 'category-weights.csv';\n    link.click();\n    URL.revokeObjectURL(url);\n  }\n  initializeCounts(variables) {\n    const next = {};\n    for (const variable of variables) {\n      next[variable.key] = {};\n      for (const category of variable.categories) {\n        next[variable.key][category.key] = 0;\n      }\n    }\n    this.counts.set(next);\n  }\n  extractCounts() {\n    const counts = [];\n    for (const [variable, categories] of Object.entries(this.counts())) {\n      for (const [category, value] of Object.entries(categories)) {\n        counts.push({\n          variable,\n          category,\n          n: value ?? 0\n        });\n      }\n    }\n    return counts;\n  }\n  cloneCounts() {\n    const snapshot = this.counts();\n    const clone = {};\n    for (const [variable, categories] of Object.entries(snapshot)) {\n      clone[variable] = {\n        ...categories\n      };\n    }\n    return clone;\n  }\n};\nAppComponent = __decorate([Component({\n  selector: 'app-root',\n  standalone: true,\n  imports: [NgIf, NgFor, FormsModule, DecimalPipe, NgClass],\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})], AppComponent);\nexport { AppComponent };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}